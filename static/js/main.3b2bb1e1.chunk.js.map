{"version":3,"sources":["RecordAudio.tsx","reportWebVitals.ts","serviceWorkerRegistration.ts","WasmRuntimeContext.tsx","index.tsx"],"names":["useState","isRecording","setIsRecording","isPaused","setIsPaused","audioData","setAudioData","stream","setStream","useEffect","navigator","mediaDevices","getUserMedia","audio","then","useAudioStream","mediaRecorder","useMemo","MediaRecorder","ondataavailable","a","data","Blob","type","URL","createObjectURL","className","onClick","stop","start","disabled","resume","pause","controls","src","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","isLocalhost","Boolean","window","location","hostname","match","registerValidSW","swUrl","config","serviceWorker","register","registration","onupdatefound","installingWorker","installing","onstatechange","state","controller","console","log","waiting","postMessage","onUpdate","onSuccess","catch","error","WasmRuntimeContext","createContext","WasmRuntimeProvider","children","wasmRuntime","setWasmRuntime","wasmModule","Provider","value","render","document","getElementById","process","href","origin","addEventListener","fetch","headers","response","contentType","get","status","indexOf","ready","unregister","reload","checkValidServiceWorker"],"mappings":"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","file":"static/js/main.3b2bb1e1.chunk.js","sourcesContent":["import { FC, useEffect, useMemo, useState } from 'react'\n\nconst useAudioStream = () => {\n  const [stream, setStream] = useState<MediaStream | null>(null)\n\n  useEffect(() => {\n    navigator.mediaDevices.getUserMedia({ audio: true }).then(setStream)\n  }, [])\n\n  return stream\n}\n\n// const useLocalStorage = (\n//   key: string,\n//   initialState: string | null = null,\n//   save: boolean = true,\n// ) => {\n//   const [storedState, setStoredState] = useState<string | null>(\n//     localStorage.getItem(key) ?? initialState,\n//   )\n\n//   useEffect(() => {\n//     if (!storedState || !save) return\n//     localStorage.setItem(key, storedState)\n//   }, [storedState, key, save])\n//   const deleteStoredData = () => {\n//     localStorage.removeItem(key)\n//     setStoredState(null)\n//   }\n\n//   return [storedState, setStoredState, deleteStoredData] as [\n//     typeof storedState,\n//     typeof setStoredState,\n//     typeof deleteStoredData,\n//   ]\n// }\n\nexport default (function App() {\n  const [isRecording, setIsRecording] = useState(false)\n  const [isPaused, setIsPaused] = useState(false)\n  const [audioData, setAudioData] = useState<string | null>(null)\n\n  const stream = useAudioStream()\n\n  const mediaRecorder = useMemo(() => {\n    if (!stream) return null\n    const mediaRecorder = new MediaRecorder(stream, {})\n    mediaRecorder.ondataavailable = async ({ data }) => {\n      const audioData = new Blob([data], { type: 'audio/mpeg' })\n      setAudioData(URL.createObjectURL(audioData))\n    }\n    return mediaRecorder\n  }, [setAudioData, stream])\n\n  if (!mediaRecorder) return null\n\n  const handleRecord = () => {\n    if (isRecording) mediaRecorder.stop()\n    else mediaRecorder.start()\n    setIsRecording(!isRecording)\n  }\n\n  const handlePause = () => {\n    if (isPaused) mediaRecorder.resume()\n    else mediaRecorder.pause()\n    setIsPaused(!isPaused)\n  }\n\n  const handleDelete = () => {\n    setAudioData(null)\n  }\n\n  return (\n    <div>\n      <div className=\"row\">\n        <button\n          className={isRecording ? 'bg-purple' : 'bg-green'}\n          onClick={handleRecord}\n        >\n          {isRecording ? 'stop' : 'start'}\n        </button>\n        <button disabled={!isRecording} onClick={handlePause}>\n          {isPaused ? 'resume' : 'pause'}\n        </button>\n        <button\n          className={audioData ? 'bg-red' : ''}\n          disabled={!audioData}\n          onClick={handleDelete}\n        >\n          delete\n        </button>\n      </div>\n      {audioData && (\n        <div className=\"row\">\n          <audio controls>\n            <source src={audioData} type=\"audio/mpeg\" />\n          </audio>\n        </div>\n      )}\n    </div>\n  )\n} as FC)\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://cra.link/PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/,\n    ),\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://cra.link/PWA',\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://cra.link/PWA.',\n              )\n              registration.waiting?.postMessage({ type: 'SKIP_WAITING' })\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.',\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister()\n      })\n      .catch(error => {\n        console.error(error.message)\n      })\n  }\n}\n","import { createContext, FC, useContext, useEffect, useState } from 'react'\n\ntype WasmRuntime = typeof import('@dothum/wasm') // alias\ntype WasmRuntimeOrNull = WasmRuntime | null\n\nconst WasmRuntimeContext = createContext<WasmRuntimeOrNull>(null)\n\nexport const WasmRuntimeProvider: FC = ({ children }) => {\n  const [wasmRuntime, setWasmRuntime] = useState<WasmRuntimeOrNull>(null)\n\n  useEffect(() => {\n    void (async () => {\n      const wasmModule = await import('@dothum/wasm')\n      setWasmRuntime(wasmModule)\n    })().catch(console.error)\n  })\n\n  if (!wasmRuntime) return null\n\n  return (\n    <WasmRuntimeContext.Provider value={wasmRuntime}>\n      {children}\n    </WasmRuntimeContext.Provider>\n  )\n}\n\nexport default function useWasmRuntime(): WasmRuntime {\n  const wasmRuntime = useContext(WasmRuntimeContext)\n  if (!wasmRuntime)\n    throw Error('useWasmRuntime: wasm runtime did not load properly')\n  return wasmRuntime\n}\n","import { StrictMode } from 'react'\nimport { render } from 'react-dom'\nimport App from './RecordAudio'\nimport reportWebVitals from './reportWebVitals'\nimport './scss/presets.scss'\nimport { register } from './serviceWorkerRegistration'\nimport { WasmRuntimeProvider } from './WasmRuntimeContext'\n\nrender(\n  <StrictMode>\n    <WasmRuntimeProvider>\n      <App />\n    </WasmRuntimeProvider>\n  </StrictMode>,\n  document.getElementById('root'),\n)\nregister()\nreportWebVitals()\n\n// window.onload = () => {\n// window.onbeforeunload = event => {\n//   event.preventDefault()\n//   return 'warning'\n// }\n\n// window.addEventListener(\n//   'beforeunload',\n//   event => {\n//     event.preventDefault()\n//     return (event.returnValue = 'Are you sure you want to exit?')\n//   },\n//   { capture: true },\n// )\n// }\n"],"sourceRoot":""}